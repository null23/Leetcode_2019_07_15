# 深度优先遍历
- 前序遍历
  - 根 + 左 + 右
- 中序遍历
  -    左 + 根 + 右
- 后序遍历
  - 左 + 右 + 根



# 广度优先遍历（层序遍历）
   按层级从上到下遍历



# 删除一个指定值的节点
1. 递归找到要删除的节点
2. 判断有没有左右子树
   - 没有左子树
     1. 直接把当前节点的引用修改成右子树的根节点
   - 没有右子树
     1. 直接把当前节点的引用修改成左子树的根节点
   - 同时拥有左右子树
     1. 找到右子树的最小值的节点minNode，删除
     2. minNode的左右孩子同当前要删除的节点
     3. 替换当前节点的引用为minNode 

# 查找某值m在二叉树中的排名
1. 在insert操作的时候，为每一个节点维护一个变量childrenCount，代表以这个节点作为根节点的左右子树的元素个数
2. 递归：
   - 从根节点开始，左右递归（这里递归是为了查找第一个小于m的值），找到第一个 <= m 的元素firstSmallNode，此元素的左子树以及包括本身，一定都小于等于元素m，因此把firstSmallNode.right（当前元素的右子树）的childrenCount+1即可
   - 找到firstSmallNode的右子树中，第一个 <= m 的元素，重复上边的步骤
   - 把所有的（childCount+1）都加起来，即可得到m在二叉树中的排名

# 二叉树的高度



# 翻转二叉树



