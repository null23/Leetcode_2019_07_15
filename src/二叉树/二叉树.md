# 深度优先遍历

- 前序遍历
  - 根 + 左 + 右
- 中序遍历
  -    左 + 根 + 右
- 后序遍历
  - 左 + 右 + 根



# 广度优先遍历（层序遍历）

   按层级从上到下遍历



# 删除一个指定值的节点

1. 递归找到要删除的节点
2. 判断有没有左右子树
   - 没有左子树
     1. 直接把当前节点的引用修改成右子树的根节点
   - 没有右子树
     1. 直接把当前节点的引用修改成左子树的根节点
   - 同时拥有左右子树
     1. 找到右子树的最小值的节点minNode，删除
     2. minNode的左右孩子同当前要删除的节点
     3. 替换当前节点的引用为minNode 



# 查找某值m在二叉树中的排名

1. 在insert操作的时候，为每一个节点维护一个变量childrenCount，代表以这个节点作为根节点的左右子树的元素个数
2. 递归：
   - 从根节点开始，左右递归（这里递归是为了查找第一个小于m的值），找到第一个 <= m 的元素firstSmallNode，此元素的左子树以及包括本身，一定都小于等于元素m，因此把firstSmallNode.right（当前元素的右子树）的childrenCount+1即可
   - 找到firstSmallNode的右子树中，第一个 <= m 的元素，重复上边的步骤
   - 把所有的（childCount+1）都加起来，即可得到m在二叉树中的排名



# 非递归的中序遍历

- 利用栈

  1. 使用栈的目的，就是为了保存前继节点的引用，使得我们在弹出打印前继节点之后，可以对前继节点的右子树进行相同的操作

  2. 如何进行操作呢？

     1） 把当前节点的所有左子树的左节点入栈

     2） 栈顶结点弹出，curNode = stack.pop()，然后curNode = curNode.right。这里就是栈的意义了，每次弹出的节点，其实都是下一层的根节点，只要我们知道当前节点的根节点是什么，我们就可以得到此根节点的右子树，对右子树进行相同的 1） 2）两步操作。





# 二叉树的高度



# 翻转二叉树





