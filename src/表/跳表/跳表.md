# 跳表 - 基于链表的 "二分查找"
我们知道，数组是连续的内存空间，可以使用二分法查找来减少时间复杂度。
但是链表在内存上并不是连续的，因此需要有额外的多级索引，通过间隔的记录来减少时间复杂度。
![跳表](https://raw.githubusercontent.com/null23/picture/master/suanfa/%E8%B7%B3%E8%A1%A8.jpg)

   Redis 的 sortedSet 就是依赖于跳表实现的，跳表的核心就是多级索引
    
## 跳表的时间复杂度
一般情况下，两个节点就会建立一个索引，但是索引的间隔是可以改变的。
   1.跳表的高度
        假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。
        如果包含原始链表这一层，整个跳表的高度就是 log2n。
        
   2.跳表的空间复杂度
        n/2+n/4+n/8…+8+4+2=n-2
        因此跳表的空间复杂度就是O(n)
        
   3.跳表的时间复杂度
        我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那么时间复杂度就是 O(m*log2n)
        那么m的值如何确定呢？在每一次向下级的索引下潜搜索的时候，会经过三个节点，因此总体的时间复杂度就是 O(3*log2n)
        也就是跳表的时间复杂度是O(logn)
        
## 跳表的插入
   我们已经了解了跳表的特性，是由多级索引维护的，如果在插入元素时，在某两个索引之间插入了太多的数，那么在跳表的时间复杂度将趋近于 O(n)
   作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降，

   如何解决这个问题呢？
   我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。
![跳表-随机函数](https://raw.githubusercontent.com/null23/picture/master/suanfa/%E8%B7%B3%E8%A1%A8-%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0.jpg)
    
   具体在 Redis 中是如何实现的，就需要额外去了解了。
   
## 跳表的删除
   如果被删除的节点在索引中也出现，那么除了删除原始链表中的节点，还要删除索引中的节点，通过指针操作完成删除(必须要获取前驱节点)。
   如果是双向链表，那么就不用考虑需要提前获取前驱节点了。
   
## Redis sortedSet 的选择：跳表 or 红黑树？
   sortedSet 主要支持以下几个核心操作：
    1.插入一个数据
    2.删除一个数据
    3.查找一个数据
    4.查找某个区间的数据(比如查找[20,50]之间的数据)
    5.迭代输出有序序列
   
   其中插入，删除，查找，迭代输出有序序列这几个操作，红黑树也是可以完成的。
   但是，查找某个区间的数据，红黑树的效率并没有跳表高。
   
   另外，还有跳表的灵活性，可以改变多级索引的构建策略，有效平衡执行效率和内存消耗。
    
   
        
                                      
        
        
   